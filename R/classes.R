
requireNamespace("tictoc")
requireNamespace("flowCore")
requireNamespace("mvtnorm")

# limits
setClass (Class="Limits", slots=c(channel="character", min="numeric", max="numeric"))

# creation function
mkLimits <- function(channel, vs)
{
  minvs <- min (vs)
  maxvs <- max (vs)
  return(new("Limits", channel=channel, min=minvs, max=maxvs))
}

limitsC <- function(l)
{
  return (c(l@min,l@max))
}



# a data object, including its limits
setClass (Class="FlowDataObject", slots=c(flowFrame="flowFrame", data="matrix", xChannel="character", yChannel="character", x="Limits", y="Limits"))
#' Creates a flow data object.
#'
#' Fill me!
#' @param frame Fill me
#' @param xChannel ...
#' @param yChannel ...
#' @export
mkFlowDataObject <- function(frame, xChannel, yChannel)
{
  data <- exprs(frame)
  xs <- data[,xChannel]
  ys <- data[,yChannel]
  return(new("FlowDataObject", flowFrame=frame, data=data, xChannel=xChannel, yChannel=yChannel
             , x=mkLimits(channel=xChannel,xs), y=mkLimits(channel=yChannel,ys)))
}



# input parameters, as a class
validFlowData <- function(object)
{
  #TODO we should check certain things
  TRUE
}
FlowData <- setClass (Class="FlowData", slots=c(data="FlowDataObject", sampled="matrix", fraction="numeric"), validity=validFlowData)

# create flow data object, including correct subsampling, etc
# fraction is the subsampling parameter, 0 < fraction <= 1
# note that the "sampled" structure retains only two dimensions

# TODO move denoised in own function, used by mkFlowDataObject

mkFractionedFlowData <- function(fdo, fraction=1.0, xMin, xMax, yMin, yMax)
{
  tic(msg="mkFractionedFlowData")
  # prepare subset extraction without border machine noise
  border <- list(c(xMin,xMax), c(yMin,yMax)) # define subset area
  names(border) <- c(fdo@xChannel, fdo@yChannel)
  denoised <- rectangleGate(filterId="Noise",  .gate = border) # filter noise
  denoised.subset <- Subset(fdo@flowFrame, denoised)
  denoisedData<-mkFlowDataObject(frame=denoised.subset, xChannel=fdo@xChannel, yChannel=fdo@yChannel)
  # subsample every nth element
  if (  length (denoisedData@data[,fdo@xChannel]) < 1
     || length (denoisedData@data[,fdo@yChannel]) < 1 ) {
    cat(sprintf("subset area selection leaves no elements left, modify xMin/xMax, yMin/yMax"))
    stop()
  }
  vs<-cbind(denoisedData@data[,fdo@xChannel],denoisedData@data[,fdo@yChannel]) #both dimensions as matrix
  # make sure to keep data ordered if no subsampled is requested
  if (fraction>=1) {
    subsampled<-vs
  } else {
    subsampled<-vs[sample(nrow(vs),size=nrow(vs) * fraction,replace=FALSE),]
  }
  colnames(subsampled) <- list(fdo@xChannel, fdo@yChannel)
  toc()

  return (new("FlowData"
              , data=denoisedData
              , sampled=subsampled
              , fraction=fraction
              ))
}



# a single run of the EM algorithm with a given number of clusters
EMRun <- setClass (Class="EMRun", slots=c(mu="matrix", sigma="list", weight="matrix", clusterProbs="numeric", logL="numeric", data="list"
                                 ))
#' Creates an object of type EMRun
#'
#' @return A new object of type EMRun, with a matrix mu, covariance matrix sigma, a matrix with weights for each sample point (weights), a probability for each cluster (clusterProbs), a log-likelihhod (logL) and a list of data
#' @export
mkEMRun <- function ()
{
  return (new("EMRun"
              , mu=matrix()
              , sigma=list()
              , weight=matrix()
              , clusterProbs=0
              , logL=Inf
              , data=list()
              ))
}



# include the newest mu, sigma, logL values in the EMRun
updateEMRun <- function (em, mu, sigma, weight, clusterProbs, logL)
{
  em@mu <- mu
  em@sigma <- sigma
  em@weight <- weight
  em@clusterProbs <- clusterProbs
  em@logL <- logL
  return (em)
}



#' Provide a label vector for each data element in an @em@ structure
#'
#' If below the cutoff, the label is set "0" to indicate background.
#' @export
getLabels <- function (em, cutoff=0.05, ksigma=2.0) {
  data <- em@data[[1]]
  # for each cluster, have mean and standard deviation
  llss <- sapply(1:length(em@sigma), function(i)
                 {
                   m <- em@mu[,i]
                   s <- em@sigma[[i]]
                   xs <- rmvnorm(1000, mean=m, sigma=s)
                   ls <- dmvnorm(xs, mean=m, sigma=s, log=TRUE)
                   ls.mean <- mean(ls)
                   ls.sd   <- sd(ls)
                   return(c(ls.mean,ls.sd))
                 })
  ms <- apply(em@weight, 1, which.max)
  f <- function (i) {
    l <- ms[i]
    m <- em@mu[,l]
    s <- em@sigma[[l]]
    bestll <- NULL
    if (!is.null(data)) {
      bestll <- dmvnorm(data@sampled[i,], mean=m, sigma=s, log=TRUE)
    }
    if (l == 1 || em@weight[[i,l]] < cutoff) {
      l <- 0
    }
    if (!(is.null(bestll)) && (l<=0 || l>ncol(llss) || bestll < llss[1,l] - ksigma*llss[2,l])) {
      l <- 0
    }
    l
  }
  ms <- sapply(1:length(ms), f)
  return (ms)
}

